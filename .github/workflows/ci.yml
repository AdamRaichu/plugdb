name: CI

on:
  - push
  - pull_request
  - workflow_dispatch  # Allow manual trigger from GitHub UI

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      submodule-matrix: ${{ steps.discover-submodules.outputs.submodule-matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
        with:
          submodules: recursive
          persist-credentials: true
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '20'

      - name: Install pnpm
        run: npm install -g pnpm

      - name: Discover submodules
        id: discover-submodules
        run: |
          node ./scripts/discover-submodules.js > submodules.json
          echo "::set-output name=submodule-matrix::$(cat submodules.json)"  # Set the output here

          echo "Submodule matrix:"
          cat submodules.json

  process-plugin:
    needs: build
    runs-on: ubuntu-latest
    strategy:
      matrix:
        repository: ${{ fromJson(needs.build.outputs.submodule-matrix) }}  # Now properly access the output
    steps:
      - name: Checkout specific submodule repository
        uses: actions/checkout@v2
        with:
          repository: ${{ matrix.repository }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '20'

      - name: Install pnpm
        run: npm install -g pnpm

      - name: Install dependencies and build plugin
        run: |
          echo "Available directories:"
          ls -l  # List contents of the current directory to verify submodule checkout

          cd ${{ matrix.repository }}
          echo "Changed directory to ${{ matrix.repository }}"

          # Check if the directory exists before trying to run pnpm
          if [ -d "$PWD" ]; then
            pnpm install
            pnpm run build
          else
            echo "Error: Directory ${{ matrix.repository }} does not exist!"
            exit 1  # Fail the job if the directory does not exist
          fi
        env:
          NODE_ENV: production

      - name: Copy files to dist
        run: |
          repo_name="${{ matrix.repository }}"  # Use the repo name
          repo_name=${repo_name##*/}             # Extract the repo name from the full path
          mkdir -p dist/"$repo_name"

          cp -r "$repo_name/plugin.json" dist/"$repo_name"/plugin.json
          cp -r "$repo_name/requirements.txt" dist/"$repo_name"/requirements.txt
          cp -r "$repo_name/README.md" dist/"$repo_name"/README.md || true
          cp -r "$repo_name/README" dist/"$repo_name"/README || true

          cd "$repo_name"

          # Handle backend
          backend=$(jq -r '.backend' plugin.json)
          if [ "$backend" != "null" ]; then
            cp -r "$backend" ../../dist/"$repo_name"/"$backend"
          fi

          # Handle include files
          include=$(jq -r '.include | join(" ")' plugin.json)
          if [ -n "$include" ]; then
            for file in $include; do
              cp -r "$file" ../../dist/"$repo_name"/"$file"
            done
          fi

          cd ../..

          # Add metadata
          echo "{\"commit\": \"$(git rev-parse HEAD)\", \"id\": \"$(git rev-list --max-parents=0 HEAD)\"}" > dist/"$repo_name"/metadata.json

      - name: Zip the plugin
        run: |
          repo_name="${{ matrix.repository }}"
          repo_name=${repo_name##*/}  # Extract the repo name from the full path
          mkdir -p build
          cd dist
          zip -r "$repo_name.zip" "$repo_name"
          mv "$repo_name.zip" ../build/"$repo_name.zip"

  finalize:
    needs: process-plugin
    runs-on: ubuntu-latest
    steps:
      - name: List built plugins
        run: ls -l build/

      - name: Run Semantic Release
        run: |
          pnpm install --save-dev semantic-release @semantic-release/changelog @semantic-release/git @semantic-release/github
          npx semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
